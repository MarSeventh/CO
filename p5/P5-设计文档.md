# P5-设计文档

#### 支持指令：add, sub, ori, lw, sw, beq, lui, jal, jr, nop

# 模块规格设计

## IFU

IFU由PC和IM组成，功能是改变PC的值，并输出对应的指令。**模块端口**定义如下：

|   信号名   | 方向 | 位宽 |                             说明                             |
| :--------: | :--: | :--: | :----------------------------------------------------------: |
|    clk     |  I   |  1   |                           时钟信号                           |
|   reset    |  I   |  1   |                         同步复位信号                         |
|   freeze   |  I   |  1   |                          冻结PC信号                          |
|   PCsel    |  I   |  1   | PC输入的选择信号。<br>PCsel为1时，PC输入来源Badder<br>PCsel为0时，PC输入来源Adder。 |
| Badder_D_o |  I   |  32  |                  当PCsel为1时PC的输入来源。                  |
|   OP_F_o   |  O   |  32  |                         要取出的指令                         |
|  PCn_F_n   |  O   |  32  |                         输出值为PC+4                         |

**模块功能**定义如下：

| 序号 | 功能名称 |                           功能说明                           |
| :--: | :------: | :----------------------------------------------------------: |
|  1   |   复位   | 同步复位，当reset信号为1且时钟上升沿来临时，PC的值初始化为0x00003000 |
|  2   | 改变PC值 | 当PCsel为1时，PC值改变为Badder的输入值；当PCsel为0时，PC值改变为PC+4 |
|  3   |  取指令  |               将PC值对应IM中的指令从OP端口输出               |
|  4   | 冻结PC值 |   当freeze信号有效时，PC值不再更新，但优先级小于reset信号    |

## Decode

Decode模块含有GRF、Badder两大部分，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             说明                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|    reset     |  I   |  1   |                         同步复位信号                         |
|     clk      |  I   |  1   |                           时钟信号                           |
|  //pipline   |      |      |                                                              |
|    OP_D_i    |  I   |  32  |                  当前Decode阶段指令的操作码                  |
|   PCn_D_i    |  I   |  32  |                      当前操作对应的PC+4                      |
| regWrite_D_i |  I   |  1   |               写使能信号（Write模块对应指令）                |
|    A3_D_i    |  I   |  5   |                        写操作目标地址                        |
|    WD_D_i    |  I   |  32  |                           写操作数                           |
|   PC_GRF_W   |  I   |  32  |                 当前Write模块指令对应的PC值                  |
|  //forward   |      |      |                                                              |
|   RD1_sel    |  I   |  1   | RD1_D_o的控制信号<br />为2'b00时，输出grf[A1]的值<br />为2'b01时，输出W_forward的值<br />为2'b10时，输出M_result的值 |
|   RD2_sel    |  I   |  1   | RD2_D_o的控制信号<br />为2'b00时，输出grf[A2]的值<br />为2'b01时，输出W_forward的值<br />为2'b10时，输出M_result的值 |
|   M_result   |  I   |  31  |         转发M寄存器目前存储的可转发值（ALU计算结果）         |
|  W_forward   |  I   |  31  | 转发W寄存器目前存储的可转发值（ALU计算结果，内存取出值，PC+8） |
| //Controller |      |      |                                                              |
|  A3_D_osel   |  I   |  2   | 输出A3_D_o的选择信号<br />当该信号为2'b10时，A3_D为31<br />当该信号为2'b01时，A3_D为OP[15:11]<br />当该信号为2'b00时，A3_D为OP[20:16] |
|    extsel    |  I   |  1   |              位扩展控制信号（0：zero 1：sign）               |
|    Basel     |  I   |  3   | 控制输出值Badder<br />当Basel==3‘b000时，或者当跳转条件不满足时，直接输出PC+4<br />当满足跳转条件时，输出PC+4+(offset<<2)<br />当Basel==3'b010时，输出{PC[31:28],OP_D_i[25:0],{2{1'b0}}}<br />当Basel==3'b011时，输出RD1_D_o的值 |
|  Badder_D_o  |  O   |  32  |              输出指令为跳转指令时PC的下一次取值              |
|   RD1_D_o    |  O   |  32  |                A1对应寄存器目前能取到的最新值                |
|   RD2_D_o    |  O   |  32  |                A2对应寄存器目前能取到的最新值                |
|    A1_D_o    |  O   |  5   |                   目前Decode模块指令A1的值                   |
|    A2_D_o    |  O   |  5   |                   目前Decode模块指令A2的值                   |
|    A3_D_o    |  O   |  5   |                   目前Decode模块指令A3的值                   |
|  extimm_D_o  |  O   |  32  |                        扩展后的立即数                        |
|   PCn_D_o    |  O   |  32  |                  目前Decode模块指令PCn的值                   |
| regwrite_D_o |  O   |  1   |                 输出目前Decode模块指令WE的值                 |
|    OP_D_o    |  O   |  32  |                        OP信号继续流水                        |



## Execute

Execute模块内主要执行ALU运算操作，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             描述                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|  //pipline   |      |      |                                                              |
|    A1_E_i    |  I   |  5   |                         A1值继续流水                         |
|    A2_E_i    |  I   |  5   |                         A2值继续流水                         |
|    A3_E_i    |  I   |  5   |                         A3值继续流水                         |
|   RD1_E_i    |  I   |  32  |                        RD1值继续流水                         |
|   RD2_E_i    |  I   |  32  |                        RD2值继续流水                         |
|   PCn_E_i    |  I   |  32  |                        PCn值继续流水                         |
|  extimm_E_i  |  I   |  32  |                     扩展后立即数继续流水                     |
| regWrite_E_i |  I   |  1   |                        WE信号继续流水                        |
|    OP_E_i    |  I   |  32  |                        OP信号继续流水                        |
| //Controller |      |      |                                                              |
|    ALU_OP    |  I   |  3   | ALU输出结果控制信号<br />为3'b000时，result=A+B<br />为3'b001时，result=A-B<br />为3'b010时，result=A\|B<br />为3'b100时，result={B[15:0],{16{1'b0}}} |
|   ALU_Bsel   |  I   |  1   |   操作数B的选择信号<br />为0时来自Brd，为1时来自extimm_E_i   |
|  //forward   |      |      |                                                              |
|   ALU_Asel   |  I   |  2   | 操作数A的转发控制信号<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD1_E_i |
|  ALU_Brdsel  |  I   |  2   | 非立即数的操作数Brd的转发控制信号<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD2_E_i |
|   M_result   |  I   |  32  |                           M转发值                            |
|  W_forward   |  I   |  32  |                           W转发值                            |
|  RD2_E_osel  |  I   |  2   | 更新流水线中RD2的流水值，使其保持最新<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD2_E_i |
|   //output   |      |      |                                                              |
|  result_E_o  |  O   |  32  |                       流水ALU计算结果                        |
|    A2_E_o    |  O   |  5   |                        继续流水A2的值                        |
|   RD2_E_o    |  O   |  32  |                   继续流水更新后的RD2的值                    |
|   PCn_E_o    |  O   |  32  |                         继续流水PC+4                         |
| regWrite_E_o |  O   |  1   |                     继续流水写寄存器信号                     |
|    A3_E_o    |  O   |  5   |                    继续流水指令对应的A3值                    |
|    OP_E_o    |  O   |  32  |                      继续流水指令操作码                      |



## Memory

Memory模块的主要部分为DM，负责对数据内存进行维护，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |              描述              |
| :----------: | :--: | :--: | :----------------------------: |
|  //pipline   |      |      |                                |
|  result_M_i  |  O   |  32  |      继续流水ALU计算结果       |
|    A2_M_i    |  O   |  5   |         继续流水A2的值         |
|   RD2_M_i    |  O   |  32  |        继续流水RD2的值         |
|   PCn_M_i    |  O   |  32  |        继续流水PC+4的值        |
| regWrite_M_i |  O   |  1   |  继续流水指令写寄存器信号的值  |
|    A3_M_i    |  O   |  5   |     继续流水指令对应A3的值     |
|    OP_M_i    |  O   |  32  |      继续流水指令的操作码      |
| //Controller |      |      |                                |
|    DM_WE     |  I   |  1   |          DM写使能信号          |
|    DM_RE     |  I   |  1   |          DM读使能信号          |
|  //forward   |      |      |                                |
|  W_forward   |  I   |  32  |        W寄存器的转发值         |
|  DM_datasel  |  I   |  1   |     选择DM输入值data的来源     |
|   //output   |      |      |                                |
|  memory_M_o  |  O   |  32  |      输出取出的内存中的值      |
|  result_M_o  |  O   |  32  |      继续流水ALU计算结果       |
|   PCn_M_o    |  O   |  32  |          继续流水PC+4          |
| regWrite_M_o |  O   |  1   | 继续流水指令的寄存器写使能信号 |
|    A3_M_o    |  O   |  5   |  继续流水指令写回寄存器的编号  |
|    OP_M_o    |  O   |  32  |      继续流水指令的操作码      |

## Write

Write模块负责将指令执行结果写回目标寄存器，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |              描述              |
| :----------: | :--: | :--: | :----------------------------: |
|  memory_W_i  |  I   |  32  |         内存中取出的值         |
|  result_W_i  |  I   |  32  |          ALU计算结果           |
|   PCn8_W_i   |  I   |  32  |       当前指令对应的PC+8       |
| regWrite_W_i |  I   |  1   |   当前指令的寄存器写使能信号   |
|    A3_W_i    |  I   |  5   |    当前指令写回的寄存器编号    |
|    OP_W_i    |  I   |  32  |        当前指令的操作码        |
| //Controller |      |      |                                |
|  GRF_WDsel   |  I   |  2   | 写回寄存器的值WD_D_i的选择信号 |
|   //output   |      |      |                                |
| regWrite_D_i |  O   |  1   |   当前指令的寄存器写使能信号   |
|    A3_D_i    |  O   |  5   |        写回的寄存器编号        |
|    WD_D_i    |  O   |  32  |        写回寄存器的数据        |
|   PC_GRF_W   |  O   |  32  |       当前指令对应的PC值       |

## Controller

Controller模块为控制信号的产生模块，**模块端口**定义如下：

|  信号名   | 数据位宽 | 方向 |                             描述                             |
| :-------: | :------: | :--: | :----------------------------------------------------------: |
|    IMD    |    32    |  I   |                     当前执行指令的机器码                     |
|   PCsel   |    1     |  O   |         为1时PC新的取值来自于Badder，否则直接为PC+4          |
|  GRF_WE   |    1     |  O   | 当指令为add/sub/ori/lw/lui/jal时，输出1<br />其他指令输出0，作为GRF模块的写入使能信号 |
|  ALU_OP   |    3     |  O   | 当指令为add/lw/sw时，输出为000，ALU进行加法运算<br />当指令为sub时，输出001，ALU进行减法运算<br />当指令为ori时，输出010，ALU进行或运算<br />当指令为lui时，输出为100，ALU将立即数加载至高位 |
|   DM_WE   |    1     |  O   |   当指令为sw时，输出为1，其他指令输出为0，接入DM的写使能端   |
|   DM_RE   |    1     |  O   |   当指令为lw时，输出为1，其他指令输出为0，接入DM的读使能端   |
| A3_D_osel |    1     |  O   | 当指令为add/sub时，输出为2'b01,<br />指令为jal时，输出为2'b10，<br />其他指令输出2'00,<br />为Decode的A3_D_o端口前的选择信号 |
| ALU_Bsel  |    1     |  O   | 当指令为ori/lw/sw/lui时，输出为1，其他指令输出为0，为ALU的B操作数前多路选择器的选择信号 |
| GRF_WDsel |    2     |  O   | 当指令为add/sub/ori/lui时，输出为2'b01,<br />指令为jal时，输出为2'b10，<br />其他指令输出为2'b00<br />写入GRF的数据的选择信号 |
|   Basel   |    3     |  O   | 当指令为beq时，输出3'b001<br />当指令为j/jal时，输出3'b010<br />当指令为jr时，输出3'b011<br />其他指令输出3'b000<br />作为Badder输出端的控制信号。 |
|   extel   |    1     |  O   | 立即数扩展结果的选择信号<br />当指令为ori时输出1,进行无符号扩展<br />其他指令输出0，进行符号扩展 |

## Forward

Forward模块为转发和暂停控制模块，负责输出freeze暂停信号和转发控制信号。**模块端口**定义如下：

|      信号名      | 数据位宽 | 方向 |                     描述                     |
| :--------------: | :------: | :--: | :------------------------------------------: |
| //forward input  |          |      |                                              |
|      OP_D_i      |    32    |  I   |               D级指令的操作码                |
|      OP_E_i      |    32    |  I   |               E级指令的操作码                |
|      OP_M_i      |    32    |  I   |               M级指令的操作码                |
|    E_regWrite    |    1     |  I   |           E寄存器指令的写使能信号            |
|    M_regWrite    |    1     |  I   |           M寄存器指令的写使能信号            |
|    W_regWrite    |    1     |  I   |           W寄存器指令的写使能信号            |
|       E_A3       |    5     |  I   |         E寄存器指令的写回寄存器编号          |
|       M_A3       |    5     |  I   |         M寄存器指令的写回寄存器编号          |
|       W_A3       |    5     |  I   |         W寄存器指令的写回寄存器编号          |
| //forward signal |          |      |                                              |
|     RD1_sel      |    2     |  O   |         Decode模块RD1_D_o的选择信号          |
|     RD2_sel      |    2     |  O   |         Decode模块RD2_D_o的选择信号          |
|     ALU_Asel     |    2     |  O   |            ALU的A操作数的选择信号            |
|    ALU_Brdsel    |    2     |  O   |              ALU的Brd的选择信号              |
|    DM_datasel    |    1     |  O   |            DM输入的data的选择信号            |
|    RD2_E_osel    |    2     |  O   |               RD2_E_o选择信号                |
|  //stop signal   |          |      |                                              |
|      freeze      |    1     |  O   | 暂停信号，使PC和D寄存器保持不变，清除E寄存器 |

# 流水线寄存器

## D

D寄存器为IFU和Decode之间的流水线寄存器，其**端口**定义如下：

| 信号名  | 方向 | 位宽 |           说明           |
| :-----: | :--: | :--: | :----------------------: |
|   clk   |  I   |  1   |         时钟信号         |
|  reset  |  I   |  1   |       同步复位信号       |
| freeze  |  I   |  1   |       冻结PC值信号       |
| OP_F_o  |  I   |  32  |  IFU取出的指令的操作码   |
| PCn_F_o |  I   |  32  |    该条指令对应的PC+4    |
| OP_D_i  |  O   |  32  | 给Decode部分输出的操作码 |
| PCn_D_i |  O   |  32  |         流水PC+4         |

## E

E寄存器为Decode和Execute之间的流水线寄存器，其**端口**定义如下：

|    信号名    | 方向 | 位宽 |                   说明                    |
| :----------: | :--: | :--: | :---------------------------------------: |
|     clk      |  I   |  1   |                 时钟信号                  |
|    reset     |  I   |  1   |               同步复位信号                |
|    freeze    |  I   |  1   |     阻塞信号，有效时需要清空该寄存器      |
|    A1_D_o    |  I   |  5   |              目前指令A1的值               |
|    A2_D_o    |  I   |  5   |              目前指令A2的值               |
|    A3_D_o    |  I   |  5   |              目前指令A3的值               |
|  extimm_D_o  |  I   |  32  |              扩展后的立即数               |
|   PCn_D_o    |  I   |  32  |              目前指令PCn的值              |
| regwrite_D_o |  I   |  1   |            输出目前指令WE的值             |
|    OP_D_o    |  I   |  32  |              OP信号继续流水               |
|    A1_E_i    |  O   |  5   |               A1值继续流水                |
|    A2_E_i    |  O   |  5   |               A2值继续流水                |
|    A3_E_i    |  O   |  5   |               A3值继续流水                |
|   RD1_E_i    |  O   |  32  |               RD1值继续流水               |
|   RD2_E_i    |  O   |  32  |               RD2值继续流水               |
|   PCn_E_i    |  O   |  32  |               PCn值继续流水               |
|  extimm_E_i  |  O   |  32  |           扩展后立即数继续流水            |
| regWrite_E_i |  O   |  1   |              WE信号继续流水               |
|    OP_E_i    |  O   |  32  |              OP信号继续流水               |
|  E_regWrite  |  O   |  1   |       目前Execute模块指令对应WE的值       |
|     E_A3     |  O   |  5   | 目前Execute模块指令对应写入寄存器的编号A3 |

## M

M寄存器为Execute和Memory之间的流水线寄存器，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |               说明                |
| :----------: | :--: | :--: | :-------------------------------: |
|     clk      |  I   |  1   |             时钟信号              |
|    reset     |  I   |  1   |           同步复位信号            |
|  //pipline   |      |      |                                   |
|  result_E_o  |  I   |  32  |        继续流水ALU计算结果        |
|    A2_E_o    |  I   |  5   |          继续流水A2的值           |
|   RD2_E_o    |  I   |  32  |          继续流水RD2的值          |
|   PCn_E_o    |  I   |  32  |           继续流水PC+4            |
| regWrite_E_o |  I   |  1   |       继续流水写寄存器信号        |
|    A3_E_o    |  I   |  5   |      继续流水指令对应的A3值       |
|    OP_E_o    |  I   |  32  |        继续流水指令操作码         |
|   //output   |      |      |                                   |
|  result_M_i  |  O   |  32  |        继续流水ALU计算结果        |
|    A2_M_i    |  O   |  5   |          继续流水A2的值           |
|   RD2_M_i    |  O   |  32  |          继续流水RD2的值          |
|   PCn_M_i    |  O   |  32  |         继续流水PC+4的值          |
| regWrite_M_i |  O   |  1   |   继续流水指令写寄存器信号的值    |
|    A3_M_i    |  O   |  5   |      继续流水指令对应A3的值       |
|    OP_M_i    |  O   |  32  |       继续流水指令的操作码        |
|   M_result   |  O   |  32  |        输出M寄存器的转发值        |
|  M_regWrite  |  O   |  1   | 输出M寄存器指令的寄存器写使能信号 |
|     M_A3     |  O   |  5   |  输出M寄存器指令写寄存器的编号A3  |

## W

W寄存器为Memory和Write模块之间的流水线寄存器，**模块端口**定义如下：

|    信号名     | 方向 | 位宽 |                             说明                             |
| :-----------: | :--: | :--: | :----------------------------------------------------------: |
|      clk      |  I   |  1   |                           时钟信号                           |
|     reset     |  I   |  1   |                         同步复位信号                         |
|   GRF_WDsel   |  I   |  2   | W_forward的输出选择信号<br />为2'b00时，输出memory<br />为2'b01时，输出result<br />为2'b10时，输出PCn8_W_i |
| //from Memory |      |      |                                                              |
|  memory_M_o   |  I   |  32  |                        内存中取出的值                        |
|  result_M_o   |  I   |  32  |                     继续流水ALU计算结果                      |
|    PCn_M_o    |  I   |  32  |                       当前指令对应PC+4                       |
| regWrite_M_o  |  I   |  1   |                继续流水指令的寄存器写使能信号                |
|    A3_M_o     |  I   |  5   |                 继续流水指令写回寄存器的编号                 |
|    OP_M_o     |  I   |  32  |                     继续流水指令的操作码                     |
|   //output    |      |      |                                                              |
|  memory_W_i   |  O   |  32  |                      流水内存中取出的值                      |
|  result_W_i   |  O   |  32  |                       流水ALU计算结果                        |
|   PCn8_W_i    |  O   |  32  |                    输出当前指令对应的PC+8                    |
| regWrite_W_i  |  O   |  1   |                  流水指令的寄存器写使能信号                  |
|    A3_W_i     |  O   |  5   |                   流水指令写回的寄存器编号                   |
|    OP_W_i     |  O   |  32  |                     继续流水指令的操作码                     |
|   W_memory    |  O   |  32  |                    继续流水内存中取出的值                    |
|   W_forward   |  O   |  32  |                       W寄存器的转发值                        |
|  W_regWrite   |  O   |  1   |                  W寄存器内指令的写使能信号                   |
|     W_A3      |  O   |  5   |               W寄存器内指令要写回的寄存器编号                |

# 思考题

### 1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

因为提前进行分支判断就要求我们在**Decode**模块便要得到分支判断条件中两个寄存器的正确数据，但是如果在分支语句前的是lw读内存的指令，就必须要使流水线暂停两个时钟周期，如果判断的结果为不分支，那么就相当于我们损失了两个时钟周期。

如：

`ori $a0,$0,1`

`ori $a1,$0,2`

`sw $a0,0($0)`

`lw $t0,0($0)`

`beq $t0,$a0,loop`

`sw $t0,4($0)`

`loop:`

`add $a2,$a0,$a1`

在这个例子中，若不提前分支判断，我们只需暂停一个时钟周期，提前后则需暂停两个时钟周期。

### 2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

因为有延迟槽，所以我们跳转指令后面的第一条指令无论是否跳转都已经执行，如果要再次回到跳转前的位置，应该是从PC+8这条指令开始继续执行。

### 3、我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？

因为流水寄存器中的数据在时钟上升沿来临时才进行更新，其余时间保持稳定，但如果直接从功能部件进行转发，则未必能保证转发数据的稳定性，可能转发错误数据。

### 4、我们为什么要使用 GPR 内部转发？该如何实现？

保证GRF输出端口输出的是新值。实现方法是在RD1和RD2输出端口前增加多路选择器，当W寄存器的指令写使能信号有效并且写回的目标寄存器和读取的寄存器编号一致时，直接将W寄存器的写回值反应到输出端口上。

### 5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

**需求者**：Decode的RD1和RD2、ALU的A和Brd、Execute的RD2_E_o、DM的data

**供给者**：M寄存器和W寄存器

**转发数据通路**：从上述的供给者到每个需求者都有数据通路，并且还有供给者到Forward模块和Forward模块到每个需求者的数据通路

### 6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

**R型/I型**：修改Execute的输出值、Controller控制信号

**DM存取**：修改DM内部输入地址和输出数据、Controller控制信号

**分支**：修改Decode内的判断模块、Badder输出模块、Controller控制信号

**跳转**：修改Badder的输出模块、Controller控制信号

### 7、简要描述你的译码器架构，并思考该架构的优势以及不足。

**译码器架构**：本次实验采用分布式译码，通过在每一个模块前对Controller的多次实例化实现对每个模块控制信号的精准输出。

**优势**：优势在于可以有效减少每个模块以及流水线寄存器输入输出端口的数量，同时实现对每个模块所需控制信号的精确输出。

**不足**：由于在每个模块前都要考虑该模块需要什么控制信号，并且多次实例化控制器，结构较为复杂！