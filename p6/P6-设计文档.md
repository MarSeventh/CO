# P6-设计文档

实现指令：add, sub, and, or, slt, sltu, lui
addi, andi, ori
lb, lh, lw, sb, sh, sw
mult, multu, div, divu, mfhi, mflo, mthi, mtlo
beq, bne, jal, jr

# 模块规格设计

## mips

mips为顶层模块，负责沟通CPU与存储器，并且将各个模块组合起来。**模块端口**定义如下：

|    信号名     | 方向 | 位宽 |                 说明                  |
| :-----------: | :--: | :--: | :-----------------------------------: |
|      clk      |  I   |  1   |               时钟信号                |
|     reset     |  I   |  1   |             同步复位信号              |
| i_inst_rdata  |  I   |  32  |         i_inst_addr对应的指令         |
| m_data_rdata  |  I   |  32  |      数据存储器中存储的相应数据       |
|  m_inst_addr  |  O   |  32  |                M级的PC                |
|  i_inst_addr  |  O   |  32  |      需要进行取值操作的流水级PC       |
|  m_data_addr  |  O   |  32  | 待写入/读出的数据在数据存储器中的地址 |
| m_data_wdata  |  O   |  32  |        待写入数据存储器的数据         |
| m_data_byteen |  O   |  4   |           4位字节的使能信号           |
|   w_grf_we    |  O   |  1   |          W级寄存器写使能信号          |
|  w_grf_addr   |  O   |  5   |          GRF待写入寄存器编号          |
|  w_grf_wdata  |  O   |  32  |             GRF待写入数据             |
|  w_inst_addr  |  O   |  32  |                 W级PC                 |



## IFU

IFU由PC和IM组成，功能是改变PC的值，并输出对应的指令。**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             说明                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|     clk      |  I   |  1   |                           时钟信号                           |
|    reset     |  I   |  1   |                         同步复位信号                         |
|    freeze    |  I   |  1   |                          冻结PC信号                          |
|    PCsel     |  I   |  1   | PC输入的选择信号。<br>PCsel为1时，PC输入来源Badder<br>PCsel为0时，PC输入来源Adder。 |
|  Badder_D_o  |  I   |  32  |                  当PCsel为1时PC的输入来源。                  |
| i_inst_rdata |  I   |  32  |                    i_inst_addr对应的指令                     |
|    OP_F_o    |  O   |  32  |                         要取出的指令                         |
|   PCn_F_n    |  O   |  32  |                         输出值为PC+4                         |
| i_inst_addr  |  O   |  32  |                     当前F阶段指令的PC值                      |

**模块功能**定义如下：

| 序号 | 功能名称 |                           功能说明                           |
| :--: | :------: | :----------------------------------------------------------: |
|  1   |   复位   | 同步复位，当reset信号为1且时钟上升沿来临时，PC的值初始化为0x00003000 |
|  2   | 改变PC值 | 当PCsel为1时，PC值改变为Badder的输入值；当PCsel为0时，PC值改变为PC+4 |
|  3   |  取指令  |               将PC值对应IM中的指令从OP端口输出               |
|  4   | 冻结PC值 |   当freeze信号有效时，PC值不再更新，但优先级小于reset信号    |

## Decode

Decode模块含有GRF、Badder两大部分，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             说明                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|    reset     |  I   |  1   |                         同步复位信号                         |
|     clk      |  I   |  1   |                           时钟信号                           |
|  //pipline   |      |      |                                                              |
|    OP_D_i    |  I   |  32  |                  当前Decode阶段指令的操作码                  |
|   PCn_D_i    |  I   |  32  |                      当前操作对应的PC+4                      |
| regWrite_D_i |  I   |  1   |               写使能信号（Write模块对应指令）                |
|    A3_D_i    |  I   |  5   |                        写操作目标地址                        |
|    WD_D_i    |  I   |  32  |                           写操作数                           |
|   PC_GRF_W   |  I   |  32  |                 当前Write模块指令对应的PC值                  |
|  //forward   |      |      |                                                              |
|   RD1_sel    |  I   |  1   | RD1_D_o的控制信号<br />为2'b00时，输出grf[A1]的值<br />为2'b01时，输出W_forward的值<br />为2'b10时，输出M_result的值 |
|   RD2_sel    |  I   |  1   | RD2_D_o的控制信号<br />为2'b00时，输出grf[A2]的值<br />为2'b01时，输出W_forward的值<br />为2'b10时，输出M_result的值 |
|   M_result   |  I   |  31  |         转发M寄存器目前存储的可转发值（ALU计算结果）         |
|  W_forward   |  I   |  31  | 转发W寄存器目前存储的可转发值（ALU计算结果，内存取出值，PC+8） |
| //Controller |      |      |                                                              |
|  A3_D_osel   |  I   |  2   | 输出A3_D_o的选择信号<br />当该信号为2'b10时，A3_D为31<br />当该信号为2'b01时，A3_D为OP[15:11]<br />当该信号为2'b00时，A3_D为OP[20:16] |
|    extsel    |  I   |  1   |              位扩展控制信号（0：zero 1：sign）               |
|    Basel     |  I   |  3   | 控制输出值Badder<br />当Basel==3‘b000时，或者当跳转条件不满足时，直接输出PC+4<br />当满足跳转条件时，输出PC+4+(offset<<2)<br />当Basel==3'b010时，输出{PC[31:28],OP_D_i[25:0],{2{1'b0}}}<br />当Basel==3'b011时，输出RD1_D_o的值 |
|  Badder_D_o  |  O   |  32  |              输出指令为跳转指令时PC的下一次取值              |
|   RD1_D_o    |  O   |  32  |                A1对应寄存器目前能取到的最新值                |
|   RD2_D_o    |  O   |  32  |                A2对应寄存器目前能取到的最新值                |
|    A1_D_o    |  O   |  5   |                   目前Decode模块指令A1的值                   |
|    A2_D_o    |  O   |  5   |                   目前Decode模块指令A2的值                   |
|    A3_D_o    |  O   |  5   |                   目前Decode模块指令A3的值                   |
|  extimm_D_o  |  O   |  32  |                        扩展后的立即数                        |
|   PCn_D_o    |  O   |  32  |                  目前Decode模块指令PCn的值                   |
| regwrite_D_o |  O   |  1   |                 输出目前Decode模块指令WE的值                 |
|    OP_D_o    |  O   |  32  |                        OP信号继续流水                        |
| //give mips  |      |      |                                                              |
|   w_grf_we   |  O   |  1   |                 W阶段指令的寄存器写使能信号                  |
|  w_grf_addr  |  O   |  5   |                       写回寄存器的编号                       |
| w_grf_wdata  |  O   |  32  |                       写回寄存器的数据                       |
| w_inst_addr  |  O   |  32  |                       写寄存器指令的PC                       |



## Execute

Execute模块内主要执行ALU运算操作，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             描述                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|  //pipline   |      |      |                                                              |
|    A1_E_i    |  I   |  5   |                         A1值继续流水                         |
|    A2_E_i    |  I   |  5   |                         A2值继续流水                         |
|    A3_E_i    |  I   |  5   |                         A3值继续流水                         |
|   RD1_E_i    |  I   |  32  |                        RD1值继续流水                         |
|   RD2_E_i    |  I   |  32  |                        RD2值继续流水                         |
|   PCn_E_i    |  I   |  32  |                        PCn值继续流水                         |
|  extimm_E_i  |  I   |  32  |                     扩展后立即数继续流水                     |
| regWrite_E_i |  I   |  1   |                        WE信号继续流水                        |
|    OP_E_i    |  I   |  32  |                        OP信号继续流水                        |
| //Controller |      |      |                                                              |
|    ALU_OP    |  I   |  3   | ALU输出结果控制信号<br />为3'b000时，result=A+B<br />为3'b001时，result=A-B<br />为3'b010时，result=A\|B<br />为3'b100时，result={B[15:0],{16{1'b0}}} |
|   ALU_Bsel   |  I   |  1   |   操作数B的选择信号<br />为0时来自Brd，为1时来自extimm_E_i   |
|     //MD     |      |      |                                                              |
|    md_op     |  I   |  3   |              乘除模块进行哪种计算类型的选择信号              |
|    start     |  I   |  1   |                       乘除模块启动信号                       |
|    mdsel     |  I   |  1   | 乘除模块输出选择信号<br />为0时，md_E_o来自LO寄存器<br />为1时，md_E_o来自HI寄存器 |
|    losel     |  I   |  1   |                   写入LO寄存器值的选择信号                   |
|     loWE     |  I   |  1   |             与start一起，做LO寄存器的写使能信号              |
|    hisel     |  I   |  1   |                  写入HI寄存器的值的选择信号                  |
|     hiWE     |  I   |  1   |             与start一起，做HI寄存器的写使能信号              |
|  //forward   |      |      |                                                              |
|   ALU_Asel   |  I   |  2   | 操作数A的转发控制信号<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD1_E_i |
|  ALU_Brdsel  |  I   |  2   | 非立即数的操作数Brd的转发控制信号<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD2_E_i |
|   M_result   |  I   |  32  |                           M转发值                            |
|  W_forward   |  I   |  32  |                           W转发值                            |
|  RD2_E_osel  |  I   |  2   | 更新流水线中RD2的流水值，使其保持最新<br />为2'b10时，来自M_result<br />为2'b01时，来自W_forward<br />为2'b00时，来自RD2_E_i |
|   //output   |      |      |                                                              |
|     busy     |  O   |  1   |           给forward模块，表示乘除模块是否正在运行            |
|    md_E_o    |  O   |  32  |                      流水乘除模块输出值                      |
|  result_E_o  |  O   |  32  |                       流水ALU计算结果                        |
|    A2_E_o    |  O   |  5   |                        继续流水A2的值                        |
|   RD2_E_o    |  O   |  32  |                   继续流水更新后的RD2的值                    |
|   PCn_E_o    |  O   |  32  |                         继续流水PC+4                         |
| regWrite_E_o |  O   |  1   |                     继续流水写寄存器信号                     |
|    A3_E_o    |  O   |  5   |                    继续流水指令对应的A3值                    |
|    OP_E_o    |  O   |  32  |                      继续流水指令操作码                      |



## Memory

Memory模块的主要部分为DM，负责对数据内存进行维护，**模块端口**定义如下：

|    信号名     | 方向 | 位宽 |                 描述                 |
| :-----------: | :--: | :--: | :----------------------------------: |
|   //pipline   |      |      |                                      |
|  result_M_i   |  I   |  32  |         继续流水ALU计算结果          |
|    A2_M_i     |  I   |  5   |            继续流水A2的值            |
|    RD2_M_i    |  I   |  32  |           继续流水RD2的值            |
|    PCn_M_i    |  I   |  32  |           继续流水PC+4的值           |
| regWrite_M_i  |  I   |  1   |     继续流水指令写寄存器信号的值     |
|    A3_M_i     |  I   |  5   |        继续流水指令对应A3的值        |
|    OP_M_i     |  I   |  32  |         继续流水指令的操作码         |
|    md_M_i     |  I   |  32  |          流水乘除模块输出值          |
| //Controller  |      |      |                                      |
|     DM_WE     |  I   |  1   |             DM写使能信号             |
|     DM_RE     |  I   |  1   |             DM读使能信号             |
|     BEsel     |  I   |  2   |          BE模块输出控制信号          |
| memory_M_osel |  I   |  3   | Memory输出从内存中取出数据的选择信号 |
|   //forward   |      |      |                                      |
|   W_forward   |  I   |  32  |           W寄存器的转发值            |
|  DM_datasel   |  I   |  1   |        选择DM输入值data的来源        |
|  //from mips  |      |      |                                      |
| m_data_rdata  |  I   |  32  |           存储器中取回数据           |
|   //output    |      |      |                                      |
|  memory_M_o   |  O   |  32  |         输出取出的内存中的值         |
|  result_M_o   |  O   |  32  |         继续流水ALU计算结果          |
|    PCn_M_o    |  O   |  32  |             继续流水PC+4             |
| regWrite_M_o  |  O   |  1   |    继续流水指令的寄存器写使能信号    |
|    A3_M_o     |  O   |  5   |     继续流水指令写回寄存器的编号     |
|    OP_M_o     |  O   |  32  |         继续流水指令的操作码         |
|    md_M_o     |  O   |  32  |          流水乘除模块输出值          |
|  //give mips  |      |      |                                      |
|  m_inst_addr  |  O   |  32  |                M级PC                 |
|  m_data_addr  |  O   |  32  |   待写入/读出的数据存储器相应地址    |
| m_data_wdata  |  O   |  32  |       待写入数据存储器相应数据       |
| m_data_byteen |  O   |  4   |             四位字节使能             |

## Write

Write模块负责将指令执行结果写回目标寄存器，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |              描述              |
| :----------: | :--: | :--: | :----------------------------: |
|  memory_W_i  |  I   |  32  |         内存中取出的值         |
|  result_W_i  |  I   |  32  |          ALU计算结果           |
|   PCn8_W_i   |  I   |  32  |       当前指令对应的PC+8       |
| regWrite_W_i |  I   |  1   |   当前指令的寄存器写使能信号   |
|    A3_W_i    |  I   |  5   |    当前指令写回的寄存器编号    |
|    OP_W_i    |  I   |  32  |        当前指令的操作码        |
|    md_W_i    |  I   |  32  |       流水乘除模块输出值       |
| //Controller |      |      |                                |
|  GRF_WDsel   |  I   |  2   | 写回寄存器的值WD_D_i的选择信号 |
|   //output   |      |      |                                |
| regWrite_D_i |  O   |  1   |   当前指令的寄存器写使能信号   |
|    A3_D_i    |  O   |  5   |        写回的寄存器编号        |
|    WD_D_i    |  O   |  32  |        写回寄存器的数据        |
|   PC_GRF_W   |  O   |  32  |       当前指令对应的PC值       |

## Controller

Controller模块为控制信号的产生模块，**模块端口**定义如下：

|    信号名     | 数据位宽 | 方向 |                             描述                             |
| :-----------: | :------: | :--: | :----------------------------------------------------------: |
|      IMD      |    32    |  I   |                     当前执行指令的机器码                     |
|     PCsel     |    1     |  O   |         为1时PC新的取值来自于Badder，否则直接为PC+4          |
|    GRF_WE     |    1     |  O   | 当指令为add/sub/ori/lw/lui/jal\|and\|slt\|sltu\|addi\|andi\|mfhi\|mflo时，输出1<br />其他指令输出0，作为GRF模块的写入使能信号 |
|    ALU_OP     |    3     |  O   | 当指令为add/lw/sw/addi时，输出为0000，ALU进行加法运算<br />当指令为sub时，输出0001，ALU进行减法运算<br />当指令为ori\|or时，输出0010，ALU进行或运算<br />当指令为lui时，输出为0100，ALU将立即数加载至高位<br />当指令为and/andi时，输出为0101，ALU进行与运算<br />当指令为slt时，输出0110，ALU进行无符号大小比较<br />当指令为sltu时，输出0111，ALU进行有符号大小比较 |
|     DM_WE     |    1     |  O   |   当指令为sw时，输出为1，其他指令输出为0，接入DM的写使能端   |
|     DM_RE     |    1     |  O   |   当指令为lw时，输出为1，其他指令输出为0，接入DM的读使能端   |
|   A3_D_osel   |    1     |  O   | 当指令为add/sub\|or\|and\|slt\|sltu\|mfhi\|mflo时，输出为2'b01,<br />指令为jal时，输出为2'b10，<br />其他指令输出2'00,<br />为Decode的A3_D_o端口前的选择信号 |
|   ALU_Bsel    |    1     |  O   | 当指令为ori/lw/sw/lui/addi/andi时，输出为1，其他指令输出为0，为ALU的B操作数前多路选择器的选择信号 |
|   GRF_WDsel   |    2     |  O   | 当指令为add/sub/ori/lui\|or\|and\|slt\|sltu/addi/andi时，输出为2'b01,<br />指令为jal时，输出为2'b10，<br />指令为mfhi\|mflo时，输出2'b11<br />其他指令输出为2'b00<br />写入GRF的数据的选择信号 |
|     Basel     |    3     |  O   | 当指令为beq时，输出3'b001<br />当指令为j/jal时，输出3'b010<br />当指令为jr时，输出3'b011<br />当指令为bne时，输出3'b100<br />其他指令输出3'b000<br />作为Badder输出端的控制信号。 |
|     extel     |    1     |  O   | 立即数扩展结果的选择信号<br />当指令为ori时输出1,进行无符号扩展<br />其他指令输出0，进行符号扩展 |
|     BEsel     |    2     |  O   | Memory中BE模块的输出值，<br />当指令为sw时，输出00<br />当指令为sh时，输出01<br />当指令为sb时，输出10 |
| memory_M_osel |    3     |  O   | Memory中输出从内存中取出数据的选择信号，<br />当指令为lw时，输出3'b000，代表不进行扩展<br />输出3'b001代表进行无符号字节扩展<br />输出3'b010代表进行符号字节扩展<br />输出3'b011代表进行无符号半字扩展<br />输出3'b100代表进行符号半字扩展 |
|     md_op     |    3     |  O   | 乘除模块进行计算类型的选择信号，<br />当指令为mult时，输出000，代表进行符号乘<br />当指令为multu时，输出001，代表进行无符号乘<br />当指令为div时，输出010，代表进行符号除<br />当指令为divu时，输出011，代表进行无符号除 |
|     start     |    1     |  O   |                       乘除模块启动信号                       |
|     mdsel     |    1     |  O   |                    乘除模块的输出选择信号                    |
|     losel     |    1     |  O   |  存入LO寄存器的值的选择信号<br />为0来自prod[31:0];为1来自A  |
|     loWE      |    1     |  O   |         当指令为mtlo时输出1，代表LO寄存器写使能信号          |
|     hisel     |    1     |  O   | 存入HI寄存器的值的选择信号<br />为0来自prod[63:32];为1来自A  |
|     hiWE      |    1     |  O   |         当指令为mthi时输出1，代表HI寄存器写使能信号          |



## Forward

Forward模块为转发和暂停控制模块，负责输出freeze暂停信号和转发控制信号。**模块端口**定义如下：

|      信号名      | 数据位宽 | 方向 |                             描述                             |
| :--------------: | :------: | :--: | :----------------------------------------------------------: |
| //forward input  |          |      |                                                              |
|       busy       |    1     |  I   | 乘除模块是否工作的标志<br />为1代表乘除模块正在进行乘除运算<br />为0代表乘除模块未进行乘除运算 |
|      start       |    1     |  I   |    乘除模块开始进行乘除运算的标志，来自于E级的Controller     |
|      OP_D_i      |    32    |  I   |                       D级指令的操作码                        |
|      OP_E_i      |    32    |  I   |                       E级指令的操作码                        |
|      OP_M_i      |    32    |  I   |                       M级指令的操作码                        |
|    E_regWrite    |    1     |  I   |                   E寄存器指令的写使能信号                    |
|    M_regWrite    |    1     |  I   |                   M寄存器指令的写使能信号                    |
|    W_regWrite    |    1     |  I   |                   W寄存器指令的写使能信号                    |
|       E_A3       |    5     |  I   |                 E寄存器指令的写回寄存器编号                  |
|       M_A3       |    5     |  I   |                 M寄存器指令的写回寄存器编号                  |
|       W_A3       |    5     |  I   |                 W寄存器指令的写回寄存器编号                  |
| //forward signal |          |      |                                                              |
|     RD1_sel      |    2     |  O   |                 Decode模块RD1_D_o的选择信号                  |
|     RD2_sel      |    2     |  O   |                 Decode模块RD2_D_o的选择信号                  |
|     ALU_Asel     |    2     |  O   |                    ALU的A操作数的选择信号                    |
|    ALU_Brdsel    |    2     |  O   |                      ALU的Brd的选择信号                      |
|    DM_datasel    |    1     |  O   |                    DM输入的data的选择信号                    |
|    RD2_E_osel    |    2     |  O   |                       RD2_E_o选择信号                        |
|  //stop signal   |          |      |                                                              |
|      freeze      |    1     |  O   |         暂停信号，使PC和D寄存器保持不变，清除E寄存器         |

# 流水线寄存器

## D

D寄存器为IFU和Decode之间的流水线寄存器，其**端口**定义如下：

| 信号名  | 方向 | 位宽 |           说明           |
| :-----: | :--: | :--: | :----------------------: |
|   clk   |  I   |  1   |         时钟信号         |
|  reset  |  I   |  1   |       同步复位信号       |
| freeze  |  I   |  1   |       冻结PC值信号       |
| OP_F_o  |  I   |  32  |  IFU取出的指令的操作码   |
| PCn_F_o |  I   |  32  |    该条指令对应的PC+4    |
| OP_D_i  |  O   |  32  | 给Decode部分输出的操作码 |
| PCn_D_i |  O   |  32  |         流水PC+4         |

## E

E寄存器为Decode和Execute之间的流水线寄存器，其**端口**定义如下：

|    信号名    | 方向 | 位宽 |                   说明                    |
| :----------: | :--: | :--: | :---------------------------------------: |
|     clk      |  I   |  1   |                 时钟信号                  |
|    reset     |  I   |  1   |               同步复位信号                |
|    freeze    |  I   |  1   |     阻塞信号，有效时需要清空该寄存器      |
|    A1_D_o    |  I   |  5   |              目前指令A1的值               |
|    A2_D_o    |  I   |  5   |              目前指令A2的值               |
|    A3_D_o    |  I   |  5   |              目前指令A3的值               |
|  extimm_D_o  |  I   |  32  |              扩展后的立即数               |
|   PCn_D_o    |  I   |  32  |              目前指令PCn的值              |
| regwrite_D_o |  I   |  1   |            输出目前指令WE的值             |
|    OP_D_o    |  I   |  32  |              OP信号继续流水               |
|    A1_E_i    |  O   |  5   |               A1值继续流水                |
|    A2_E_i    |  O   |  5   |               A2值继续流水                |
|    A3_E_i    |  O   |  5   |               A3值继续流水                |
|   RD1_E_i    |  O   |  32  |               RD1值继续流水               |
|   RD2_E_i    |  O   |  32  |               RD2值继续流水               |
|   PCn_E_i    |  O   |  32  |               PCn值继续流水               |
|  extimm_E_i  |  O   |  32  |           扩展后立即数继续流水            |
| regWrite_E_i |  O   |  1   |              WE信号继续流水               |
|    OP_E_i    |  O   |  32  |              OP信号继续流水               |
|  E_regWrite  |  O   |  1   |       目前Execute模块指令对应WE的值       |
|     E_A3     |  O   |  5   | 目前Execute模块指令对应写入寄存器的编号A3 |

## M

M寄存器为Execute和Memory之间的流水线寄存器，**模块端口**定义如下：

|    信号名    | 方向 | 位宽 |                             说明                             |
| :----------: | :--: | :--: | :----------------------------------------------------------: |
|     clk      |  I   |  1   |                           时钟信号                           |
|    reset     |  I   |  1   |                         同步复位信号                         |
| //Controller |      |      |                                                              |
|  GRF_WDsel   |  I   |  2   | 转发值M_result的选择信号<br />为01时，来自result<br />为11时，来自md |
|  //pipline   |      |      |                                                              |
|  result_E_o  |  I   |  32  |                     继续流水ALU计算结果                      |
|    A2_E_o    |  I   |  5   |                        继续流水A2的值                        |
|   RD2_E_o    |  I   |  32  |                       继续流水RD2的值                        |
|   PCn_E_o    |  I   |  32  |                         继续流水PC+4                         |
| regWrite_E_o |  I   |  1   |                     继续流水写寄存器信号                     |
|    A3_E_o    |  I   |  5   |                    继续流水指令对应的A3值                    |
|    OP_E_o    |  I   |  32  |                      继续流水指令操作码                      |
|    md_E_o    |  I   |  32  |                      流水乘除模块输出值                      |
|   //output   |      |      |                                                              |
|    md_M_i    |  O   |  32  |                      流水乘除模块输出值                      |
|  result_M_i  |  O   |  32  |                     继续流水ALU计算结果                      |
|    A2_M_i    |  O   |  5   |                        继续流水A2的值                        |
|   RD2_M_i    |  O   |  32  |                       继续流水RD2的值                        |
|   PCn_M_i    |  O   |  32  |                       继续流水PC+4的值                       |
| regWrite_M_i |  O   |  1   |                 继续流水指令写寄存器信号的值                 |
|    A3_M_i    |  O   |  5   |                    继续流水指令对应A3的值                    |
|    OP_M_i    |  O   |  32  |                     继续流水指令的操作码                     |
|   M_result   |  O   |  32  |                     输出M寄存器的转发值                      |
|  M_regWrite  |  O   |  1   |              输出M寄存器指令的寄存器写使能信号               |
|     M_A3     |  O   |  5   |               输出M寄存器指令写寄存器的编号A3                |

## W

W寄存器为Memory和Write模块之间的流水线寄存器，**模块端口**定义如下：

|    信号名     | 方向 | 位宽 |                             说明                             |
| :-----------: | :--: | :--: | :----------------------------------------------------------: |
|      clk      |  I   |  1   |                           时钟信号                           |
|     reset     |  I   |  1   |                         同步复位信号                         |
|   GRF_WDsel   |  I   |  2   | W_forward的输出选择信号<br />为2'b00时，输出memory<br />为2'b01时，输出result<br />为2'b10时，输出PCn8_W_i |
| //from Memory |      |      |                                                              |
|  memory_M_o   |  I   |  32  |                        内存中取出的值                        |
|  result_M_o   |  I   |  32  |                     继续流水ALU计算结果                      |
|    PCn_M_o    |  I   |  32  |                       当前指令对应PC+4                       |
| regWrite_M_o  |  I   |  1   |                继续流水指令的寄存器写使能信号                |
|    A3_M_o     |  I   |  5   |                 继续流水指令写回寄存器的编号                 |
|    OP_M_o     |  I   |  32  |                     继续流水指令的操作码                     |
|    md_M_o     |  I   |  32  |                      流水乘除模块输出值                      |
|   //output    |      |      |                                                              |
|    md_W_i     |  O   |  32  |                      流水乘除模块输出值                      |
|  memory_W_i   |  O   |  32  |                      流水内存中取出的值                      |
|  result_W_i   |  O   |  32  |                       流水ALU计算结果                        |
|   PCn8_W_i    |  O   |  32  |                    输出当前指令对应的PC+8                    |
| regWrite_W_i  |  O   |  1   |                  流水指令的寄存器写使能信号                  |
|    A3_W_i     |  O   |  5   |                   流水指令写回的寄存器编号                   |
|    OP_W_i     |  O   |  32  |                     继续流水指令的操作码                     |
|   W_memory    |  O   |  32  |                    继续流水内存中取出的值                    |
|   W_forward   |  O   |  32  |                       W寄存器的转发值                        |
|  W_regWrite   |  O   |  1   |                  W寄存器内指令的写使能信号                   |
|     W_A3      |  O   |  5   |               W寄存器内指令要写回的寄存器编号                |

# 实现方案：

## 1.lb/lh

第一步，修改数据通路，数据通路和lw指令类似，在Memory模块输出时增加多选器即可

第二步，修改控制器，给Memory输出模块增加选择信号

第三步，转发和暂停信号，这两条指令发生转发和暂停的地方与lw完全一致，合并为load即可

第四步，测试。测试暂停、转发和指令自身行为是否正确

```asm
ori $25,$0,1
ori $t1,$0,0x0011ff00
sw $t1,0($0)
lb $t2,1($0)
add $t2,$t2,$25
lb $t3,2($0)
lh $t4,0($0)
lh $t5,2($0)
sw $t2,4($0)
sw $t3,8($0)
sw $t4,12($0)
sw $t5,16($0)
```



## 2.sb/sh

第一步，修改数据通路，数据通路和sw类似，在Memory中加入BE模块即可，BE模块需要产生位使能信号和拓展后的data值。

第二步，修改控制器，这两条指令除BE外与sw完全一致，合并为upload即可。

第三步，转发和暂停，这部分与sw完全一致

第四步，测试。

```asm
ori $t0,$0,0xff11
ori $t2,$0,11
sb $t0,0($0)
add $t1,$0,$t2
sb $t0,6($t1)
sb $t0,11($0)
sh $t0,6($0)
```



## 3.and/or

and:op=6'b000000 func=6'b100100

or:op=6'b000000 func=6'b100101

第一步，修改Ex模块，在其中加入and和or指令的输出结果

第二步，修改控制器，对这两条指令添加相应控制信号。具体为：

and:GRF_WE=1    ALU_OP=3'b101     A3_D_osel=2'b01    GRF_WDsel=2'b01

or:GRF_WE=1    ALU_OP=3'b010     A3_D_osel=2'b01    GRF_WDsel=2'b01

第三步，转发和暂停。这一部分与其他R型指令完全相同

第四步，测试。

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
ori $t2,$0,0x3fde
and $t3,$t1,$t2
sh $t3,0($0)
lh $t4,0($0)
or $t5,$t3,$t4
```

## 4.slt/sltu

slt:op=6'b000000 func=6'b101010

sltu:op=6'b000000 func=6'b101011

第一步，修改Ex模块根据相应控制信号以及两数比较结果添加相应输出信号

第二步，修改控制器，对这两条指令添加相应控制信号。具体为：

slt:GRF_WE=1    ALU_OP=4'b0110    A3_D_osel=2'b01     GRF_WDsel=2'b01

sltu:GRF_WE=1    ALU_OP=4'b0111    A3_D_osel=2'b01    GRF_WDsel=2'b01

第三步，转发和暂停。这部分与其他R型指令一致。

第四步，测试。

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
ori $t2,$0,1
slt $t3,$t1,$t2
sltu $t4,$t1,$t2
```

## 5.addi/andi

addi:op=6'b001000

andi:op=6'b001100

第一步，数据通路。addi在Ex中计算与add相同，andi计算与and相同，所以不需要新的控制信号

第二步，修改控制器，对这两条指令添加相应控制信号。具体为：

addi:GRF_WE=1    ALU_OP=0000    A3_D_osel=00    ALU_Bsel=1    GRF_WDsel=01    extel=0

andi:GRF_WE=1    ALU_OP=0101    A3_D_osel=00    ALU_Bsel=1    GRF_WDsel=01    extel=1

第三步，转发与暂停。这部分与其他I型指令一致。

第四步，测试。

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
addi $t2,$t1,2
andi $t3,$t1,0xfed3
```



## 6.bne

bne:op=6'b000101

第一步，数据通路。与beq相同，增加Decode内Badder模块的输出即可

第二步，修改控制器，对这条指令添加相应控制信号。具体为：

bne:PCsel=1    Basel=3'b100

第三步，转发与暂停。这部分与beq一致。

第四步，测试。

跳：

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
ori $t2,$0,0xffea
bne $t1,$t2,loop
sw $t1,0($0)
sw $t1,4($0)
loop:
sw $t2,8($0)
```

不跳：

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
ori $t2,$t0,0xffff
bne $t1,$t2,loop
sw $t1,0($0)
sw $t1,4($0)
loop:
sw $t2,8($0)
```

发现：实际执行时依然跳转，检查后发现forward模块中判断指令类型时有误，[31:26]误写为[31:25]。

## 乘除模块测试

1.

```asm
ori $t0,$0,2
lui $t1,0xffff
ori $t1,$t1,0xffff
multu $t0,$t1
mflo $s0
ori $t3,$0,0xffff
mult $s0,$t3
mthi $t1
mtlo $s0
mfhi $s1
mflo $s2
divu $t3,$t1
mfhi $s3
mflo $s4
```

2.

```asm
ori $t0,$0,2
lui $t1,0xffff
ori $t1,$t1,0xffff
multu $t0,$t1
mflo $s0
ori $t3,$0,0xffff
mthi $t1
mtlo $s0
mult $s0,$t3
mfhi $s1
mflo $s2
divu $t3,$t1
mfhi $s3
mflo $s4
```

问题：有符号乘时，没有将A和B符号扩展为64位就直接相乘，正确写法为$signed({{32{A[31]}},A[31:0]}*{{32{B[31]}},B[31:0]})

3.

```asm
ori $t0,$0,0xef32
ori $t1,$0,0x2d3a
ori $t2,$0,0x5543
mthi $t2
mfhi $t3
divu $t1,$t2
mfhi $t4
mtlo $t1
mthi $t1
mfhi $t5
```

问题：先mthi再mfhi时会出现不定值。发现是count未初始化，导致busy开始时未初始化，第一次mfhi时输出的选择信号无效。

## 思考题

### 1.为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？

因为乘除法需要的时钟周期较长，在这一段时间内ALU仍可以执行其他指令以提高CPU效率，所以不能整合进ALU中。独立的HI、LO寄存器也是为了尽可能地减少乘除模块与其他指令之间的关联，只要没有用到乘除模块计算结果的指令都可以继续执行，减少因为需要用到乘除模块结果而阻塞流水线较长时间的情况发生。

### 2.真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。

**乘法**：采用循环迭代的方法。如果B的最低位为0，则B>>1，高位补0；如果B的最高位为1，则将A的值高位对齐加到积寄存器中，然后B>>1，高位补0.

对于有符号乘法，先把符号记录下来，然后都转化为正数，进行无符号乘法，最后再加上符号。

**除法**：首先定义32位商寄存器，32位除数寄存器，65位余数寄存器。商寄存器初始置0，除数寄存器初始化为除数，余数寄存器左半置为0，右32位初始化为32位被除数。

开始循环后，首先商寄存器左移一位，最低位填充1，余数寄存器减掉除数计数器的值；然后判断余数是否小于0，若是则余数寄存器加上除数寄存器的内容，商寄存器的最低位置为0；最后除数寄存器右移一位。如果已经进行32次循环，则结束计算，否则再次进入循环。

对于有符号除法，保存除数和被除数符号，然后转化为正数，进行无符号数除法，最后加上符号即可。

### 3.请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？

将busy信号交给forward模块，在forward模块内部判断如果busy为1，同时D级执行的指令是和乘除模块有关的指令，那么就阻塞流水线。busy信号自身在Execute中产生。

### 4.请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）

从清晰性角度来看，每一个字节使能控制一个字节是否能够写入，互不干扰，并且写入数据和代写入位置的字按照字节一一对应，在进行写入时十分清晰明了。

从统一性角度来看，采用字节使能的方式进行写指令，在提前准备好数据的前提下，写入时不需要考虑写入指令到底是哪一个，只需要将每一字节一一对应即可，使每个写入指令具有了统一性。

### 5.请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？

不是，实际获得和写入的仍然是一个字。

当DM按字节编址时按字节读写的效率高于按字读写，

### 6.为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？

抽象手段：尽量减少模块之间的耦合性，减少每个模块和外界沟通的端口。例如新增的乘除模块，只需要从外部接入clk、reset、以及几个控制信号，而输出只有md_E_o端口和busy端口。

规范手段：在Forward模块中，将OP[31:26]定义为OP_op，将OP[5:0]定义为OP_func，在之后的代码中直接用名称判断即可，增强了可读性。在Controller模块中，将信号类型判断和控制信号生成部分清晰地划分开，使代码块清晰明了。在输入输出端口对来自不同模块或者送往不同模块的信号用注释进行标记，增强可读性。

帮助：在处理数据冲突时，不需要频繁地写[31:26]和[5:0]，减少了代码复杂性，提高了可读性。在译码过程中，分开的代码块使得在加指令时减少了混乱，提高了正确性。

### 7.在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？

​       1、ALU计算指令和跳转指令有冲突。解决方案是优先考虑转发，如果转发失效则进行阻塞。测试样例如下：

```asm
lui $t0,0xffff
ori $t1,$t0,0xffff
ori $t2,$0,0xffea
bne $t1,$t2,loop
sw $t1,0($0)
sw $t1,4($0)
loop:
sw $t2,8($0)
```

​       2、load指令和ALU计算指令、跳转指令有冲突。解决方案依然是转发和暂停。测试样例如下：

```asm
ori $25,$0,1
ori $t1,$0,0x0011ff00
sw $t1,0($0)
lb $t2,1($0)
add $t2,$t2,$25
lb $t3,2($0)
lh $t4,0($0)
lh $t5,2($0)
sw $t2,4($0)
sw $t3,8($0)
sw $t4,12($0)
sw $t5,16($0)
```

​        3、upload指令和load指令，ALU计算指令有冲突

### 8.如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证**覆盖**了所有需要测试的情况；如果你是**完全随机**生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了**特殊的策略**，比如构造连续数据冒险序列，请你描述一下你使用的策略如何**结合了随机性**达到强测的效果。

我采用的是对每一条新增指令独立测试的方法，在保证之前指令正确性的基础上，尽量充分考虑其他指令影响该条指令以及该条指令影响其他指令的情况。例如新增的lb指令，要测试当lb指令用到的base寄存器在前面邻近指令刚刚修改的情况，同时考虑lb自身取出数据的正确性，再考虑lb存入的寄存器在下面紧邻指令中使用的情况。
