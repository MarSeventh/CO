# P7-设计文档

## 任务清单：

![image-20221201154838754](https://alist.sanyue.site/d/imgbed/202311252316220.png)

## 框架图：

![image-20221201155251041](https://alist.sanyue.site/d/imgbed/202311252316743.png)

## 地址空间：

![image-20221201155513542](https://alist.sanyue.site/d/imgbed/202311252316395.png)

## 实现思路：

### 1、重构CPU模块

将原来mips.v下面的模块整合为CPU模块，并且连接号相应端口。

### 2、系统桥的实现（Bridge）

系统桥的作用即沟通CPU与外设，起到传输数据的作用，其**模块端口**定义如下：

|        信号名        | 方向 | 位宽 |              说明               |
| :------------------: | :--: | :--: | :-----------------------------: |
|      //from CPU      |      |      |                                 |
|       br_addr        |  I   |  32  |      CPU给出的读写外设地址      |
|       br_wdata       |  I   |  32  |     CPU给出的写入外设的数据     |
|      br_byteen       |  I   |  4   | CPU给出的写入外设的字节使能信号 |
|      //get data      |      |      |                                 |
|     m_data_rdata     |  I   |  32  |          DM返回的数据           |
|     Timer1_rdata     |  I   |  32  |        Timer1返回的数据         |
|     Timer2_rdata     |  I   |  32  |        Timer2返回的数据         |
|     //give data      |      |      |                                 |
|     m_data_addr      |  O   |  32  |         给DM的读写地址          |
|     m_data_wdata     |  O   |  32  |         给DM的写入数据          |
|      m_int_addr      |  O   |  32  |      给中断发生器的写地址       |
|     Timer1_addr      |  O   |  32  |       给Timer1的读写地址        |
|     Timer1_wdata     |  O   |  32  |       给Timer1的写入数据        |
|     Timer2_addr      |  O   |  32  |       给Timer2的读写地址        |
|     Timer2_wdata     |  O   |  32  |       给Timer2的写入数据        |
| //return data to CPU |      |      |                                 |
|       br_rdata       |  O   |  32  |   系统桥给CPU返回读取到的数据   |
|   //enable signal    |      |      |                                 |
|    m_data_byteen     |  O   |  4   |       给DM的字节使能信号        |
|     m_int_byteen     |  O   |  4   |   给中断发生器的字节使能信号    |
|      Timer1_en       |  O   |  1   |      给Timer1的写使能信号       |
|      Timer2_en       |  O   |  1   |      给Timer2的写使能信号       |

### 3、CP0的实现

将CP0模块置于Me模块中，既能保证覆盖绝大多数异常，又便于恢复该指令执行之前的状态。

CP0模块的端口定义如下：

|  信号名   | 方向 | 位宽 |        说明        |
| :-------: | :--: | :--: | :----------------: |
|    clk    |  IN  |  1   |     时钟信号。     |
|   reset   |  IN  |  1   |     复位信号。     |
|    en     |  IN  |  1   |    写使能信号。    |
|  CP0Add   |  IN  |  5   |    寄存器地址。    |
|   CP0In   |  IN  |  32  |   CP0 写入数据。   |
|  CP0Out   | OUT  |  32  |   CP0 读出数据。   |
|    VPC    |  IN  |  32  |     受害 PC。      |
|   BDIn    |  IN  |  1   | 是否是延迟槽指令。 |
| ExcCodeIn |  IN  |  5   |   记录异常类型。   |
|   HWInt   |  IN  |  6   |   输入中断信号。   |
|  EXLClr   |  IN  |  1   |   用来复位 EXL。   |
|  EPCOut   | OUT  |  32  |     EPC 的值。     |
|    Req    | OUT  |  1   | 进入处理程序请求。 |

CP0模块设计完成之后，将其放入CPU的Memory模块，然后设计相应的数据通路。主要包含：将中断信号从CPU外部引入CP0模块；设计从Memory级的Controller到CP0的控制信号通路；流水中增加Delay、ExcCode；设计读出CP0中寄存器的数据通路；将EPC引入Decode模块用于eret跳转；将Req信号引入各级流水线寄存器，乘除模块寄存器，改变sw使能信号，修改PC值到异常处理程序地址。

### 4、新增指令

#### mfc0:

op=6'b010000     OP[25:21]=5'b00000

修改数据通路：从CP0中读取的寄存器编号为OP[15:11]，写回寄存器编号为OP[20:16]，只需要将CP0读出值和原来的memory_M_o通过一个多路选择器进行选择即可。

添加控制信号：GRF_WE=1   memory_M_osel=3'b101

转发和阻塞：在Memory模块产生新的值，无需使用寄存器的值

#### mtc0:

op=6'b010000    OP[25:21]=5'b00100

修改数据通路：将RD2的值存入CP0中编号为OP[15:11]的寄存器，故无需修改数据通路。

添加控制信号：CP0_WE=1

转发和阻塞：rtTuse==2,

#### syscall:

只需要在Controller中增加对应异常码即可

#### eret:

op=6'b010000    func=6'b011000

修改数据通路：将EPC的值接入Badder模块，同时从Controller引出一个新的控制信号brclr,用来清空延迟槽

添加控制信号：Basel=3'b101   brclr=1    PCsel=1    EXLClr=1

阻塞：直接将流水线阻塞两个周期即可，保证EPC为最新。

## 测试方案：

### 异常检测：

#### 1、Adel

lw取数地址未与4对齐

```asm
ori $2,$0,0xefff
sw $2,0($0)
lw $3,1($0)
lw $3,0($0)
lw $4,0($0)
```

lh取数地址未与2对齐

```asm
ori $2,$0,0xefff
sw $2,0($0)
lh $3,1($0)
lw $3,0($0)
lw $4,0($0)
```

lh、lb取Timer寄存器的值

```asm
ori $2,$0,0x7f00
sw $2,0($0)
lh $3,0($2)
lw $3,0($0)
lw $4,0($0)
```

load地址加法溢出

```asm
lui $2,0x7fff
ori $2,$2,0xffff
lb $3,1($2)
lw $3,0($0)
lw $4,0($0)
```

load取数地址超范围

```asm
ori $2,$0,0x3000
lb $3,1($2)
lw $3,0($0)
lw $4,0($0)
```

#### 2、Ades

store向Count寄存器存值

```asm
ori $2,$0,0x7f08
lw $3,0($0)
sb $3,1($2)
lw $4,0($0)
```

#### 3、syscall

```asm
ori $2,$0,0xefff
sw $2,0($0)
lh $3,0($0)
syscall
lw $3,0($0)
lw $4,0($0)
```

#### 4、Ov

```asm
lui $2,0x7fff
ori $2,$2,0xffff
ori $4,$0,1
add $3,$2,$4
lw $5,0($0)
```

此处发现一处bug，Ex模块里面的溢出判断有误。

### 操作C0中寄存器

#### mfc0\mtc0:

```asm
ori $t0,$0,0x7fff
mtc0 $t0,$12
mfc0 $t1,$12
```

#### eret:

```asm
ori $2,$0,0xefff
ori $t0,$0,0x3020
mtc0 $t0,$14
sw $2,0($0)
lh $3,0($0)
eret
lw $4,0($0)
lw $5,0($0)
lw $6,0($0)
```

此处发现bug，eret指令没能成功执行，跳转失败。发现问题是D寄存器的brclr和freeze优先级错误，freeze优先级应该更高。

### 测试流水线阻塞时中断信号在空泡处产生：

```asm
ori $t0,$0,1
ori $t1,$0,1
sw $t0,0($0)
lw $t2,0($0)
add $t2,$t2,$t2
mfc0 $t3,$14
```

发现的bug是阻塞时空泡的PC与前一条指令的PC保持了一致，正确的应该与被阻塞的PC保持一致。

## 思考题：

#### 1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？

键盘和鼠标本质上都属于输入设备，内部有很多微处理器来控制自身与主机的交互，并且交互的过程中需要驱动程序的协助。他们产生的信号会经过主存、cache、bridge等层级到达CPU，而CPU对他们的控制也会通过反向的路径送往他们。

#### 2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）

指定好的地址便于发生异常时CPU可以直接跳转到相应的异常处理程序，而无需与外界进行交互，减少可能出现的错误。

如果CPU支持自定义入口地址，也能实现我们所希望的功能。

可能出现的问题是CPU在用户还未提供入口地址时发生中断异常，那么CPU此时不能跳转到正确的异常中断处理程序，导致CPU无法正确处理异常和中断以及后续所有指令。

#### 3、为何与外设通信需要 Bridge？

因为同一CPU可能需要与很多个外设进行通信，但是由于CPU与外设通信的方式限制，他同一时间只能与一个外设进行通信，使用Bridge可以方便的控制CPU在某一时刻通信的对象，减少CPU引出来的接口数量，同时将外设返回的信息经过筛选反馈给CPU，保证了CPU的正确执行。

#### 4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。

模式0和模式1的异同：

相同之处在于计数器计数到0且中断屏蔽位无效时，均会产生中断信号。

不同之处在于模式0的计数器计数到0后计数使能会自动关闭，并且中断信号持续有效；模式1在计数到0之后

不会自动关闭，而是重新加载初值并且开始计数，所以中断信号只能有效一周期。

状态转移图如下：![1_ae7](https://alist.sanyue.site/d/imgbed/202311252316570.png)

#### 5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？

存入EPC的值为空，会导致异常处理程序执行完之后无法回到原来程序的执行位置。应该保留指令的PC和延迟槽标记。

#### 6、为什么 `jalr` 指令为什么不能写成 `jalr $31, $31`？

因为$31保存的是函数入口地址，如果将其改变下一次无法再次进入函数。



## 设计草稿：

![1_f03](https://alist.sanyue.site/d/imgbed/202311252316009.png)
